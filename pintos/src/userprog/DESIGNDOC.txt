		     +--------------------------+       	       	     |		CS 5600		|		     | PROJECT 2: USER PROGRAMS	|		     | 	   DESIGN DOCUMENT     	|		     +--------------------------+---- GROUP ---->> Fill in the names and email addresses of your group members.Tianshu  Peng    <pengt@ccs,neu.edu>Chen     Bai     <chbai@ccs.neu.edu>Gang     Liu     <beyou@ccs.neu.edu>---- PRELIMINARIES ---->> If you have any preliminary comments on your submission, notes for the>> TAs, or extra credit, please give them here.>> Please cite any offline or online sources you consulted while>> preparing your submission, other than the Pintos documentation, course>> text, lecture notes, and course staff.http://man7.org/linux/man-pages/man3/strtok.3.html			   ARGUMENT PASSING			   ================---- DATA STRUCTURES ---->> A1: Copy here the declaration of each new or changed `struct' or>> `struct' member, global or static variable, `typedef', or>> enumeration.  Identify the purpose of each in 25 words or less.******************************************************************************************We did not create any new struct, global of static variables to implementargument passing. However, we designed separate functions for the task,they are in process.c:/* Input the value of *esp after some modification in setup_stack(), check whether such modification is possible. If such modification would cause problems, return false.*/bool check_esp(unsigned esp);/* Extract the executable file_name which we want to open from a completed cmdline which contains other arguments. */  char *determine_argument(char *file_name);/* Modify the original setup_stack() function. Add a new parameter ‘char *file_name’ to deliver the complete cmdline. */static bool setup_stack(void **esp, char *file_name)******************************************************************************************---- ALGORITHMS ---->> A2: Briefly describe how you implemented argument parsing.  How do>> you arrange for the elements of argv[] to be in the right order?>> How do you avoid overflowing the stack page?******************************************************************************************To implement argument parsing, we first extract the executable file_name before a ‘ ‘ from the cmdline and save that as a real file_name and used it to define our process. When we setup the stack, we first scan from right to left to find each argument within the cmdline using a for loop of strtok_r() defined in the comment of strtok_r() in string.c after we initialized argc as 0, and for each argument we can extract, we may check if there are available space for such arguments in the stack by check_esp() then push it on top of user stack starting from PHYS_BASE - 1. At this point, we also save each argument in argv[argc++]. So for argv[i], the smaller the value of i, the more to the left the position of argument. After successfully pushing all the arguments, we could find the value of argc, so we are able to check whether there is enough space for the rest of variables we need to put into the stack. Then we would insert word-alignment segement for better accessing speed. After doing that, we scan the address for each argv[i] and use a for loop to insert the address value in a decrease order of i. So the leftmost argument would stored in the bottom and the rightmost argument would be stored on the top.(we need to decrease esp when we insert value in the esp) Thus, the arguments would in the right order since arguments are read from left to right when stack pointer goes up in convention. Finally we could put in the argc value and fake return value on the bottom.We would use check_esp() to check whether the next step to modify the stack is ok, if that operation would cause stack overflow , we would prevent such operation and return false. Besides, we fixed the size of argv[] to 64 which would cause a false return if more than 64 words exist in cmdline which could cause stack overflow. 64 words is quite enough for most potential cmdline, more words implemence would waste a lots of space for this linear structure.******************************************************************************************---- RATIONALE ---->> A3: Why does Pintos implement strtok_r() but not strtok()?******************************************************************************************strtok() uses a static buffer while parsing, so it’s not thread safe. And in pinots, we need such function to be thread safe. So we use strtok_r() instead of strtok().******************************************************************************************>> A4: In Pintos, the kernel separates commands into a executable name>> and arguments.  In Unix-like systems, the shell does this>> separation.  Identify at least two advantages of the Unix approach.******************************************************************************************The first advantage would be such operation could shorten the calculation time in the kernel because the separation work is done by shell before put it into kernel.Besides, the Unix approach would be safer because the shell itself would first eliminate potential erroneous arguments which may crush the kernel.******************************************************************************************			     SYSTEM CALLS			     ============---- DATA STRUCTURES ---->> B1: Copy here the declaration of each new or changed `struct' or>> `struct' member, global or static variable, `typedef', or>> enumeration.  Identify the purpose of each in 25 words or less.******************************************************************************************In process.h:/* Structure to save the child process imformation */struct child_process_elem{/* process id*/pid_t pid;/* check whether wait is already called for this process by it’s parent. */bool process_wait;/* check whether the process is terminated by system call EXIT. */ bool exit;/* record the return outcome of load() */bool load;/* record the return status of this process */int status;/* list_elem in the parent’s child_process_list */struct list_elem elem;/* list for all the file it opened */struct list file_list;/* semaphore to wait for the load() function finished */struct semaphore load_barrier;/* semaphore to wait this process exit */struct semaphore wait_barrier;/* save the value of next file description */int next_fd;};/* find a child_process_elem in current thread’s child_process_list according to a pid */struct child_process_elem *get_child(pid_t pid);/* create a child_process_elem as a child of current thread */struct child_process_elem *create_child(pid_t pid);/* initiate a child_process_elem, allocate memory space for this element */void child_init(struct child_process_elem *child);/* remove a child_process_elem, free the memory space of this element */void remove_child(struct child_process_elem *child);in thread.h:struct thread{. . ./* store the tid of its parent to prevent potential crush caused by orphans condition */tid_t parent;/* store the process_elem binding with this thread */struct child_process_elem *process;/* store all the child process of this thread */struct list child_process_list;/* store the executed file for this thread */struct file *file};/* check whether the thread with such tid is still alive */bool thread_exist(tid_t tid);in syscall.c:/* define the value of code segment base described in http://www.ccs.neu.edu/home/ntuck/courses/S15/cs5600/pintos/pintos_3.html */#define CODE_BASE ((void *) 0x08048000)/* check whether such esp is ok to access and whether the address is being mapped, if not, exit the process */void check_valid_esp(const void *esp);/* halt the machine */void halt(void);/* exit the process, if the parent of current process is still alive, deliver the return value. */void exit(int status);/* execute a cmd_line */pid_t exec(const char*cmd_line);/* wait for a process with the input pid */int wait(pid_t pid);/* remove file from the file list of current process */bool remove (const char *file);/* create a file and add the file to file list */bool create (const char *file, unsigned initial_size);/* return the file size with the input file description number */int filesize (int fd);/* read length bytes from file with fd file description into the buffer */int read (int fd, void *buffer, unsigned length);/* write length bytes from buffer into file with fd file description */int write (int fd, const void *buffer, unsigned length);/* seek the file with fd file description in position */void seek (int fd, unsigned position);/* return the position of file with fd */unsigned tell (int fd);/* close the file with fd */void close (int fd);/* close all the files in the file list of current process */void close_all (void);/* find the file with fd in the file list of input process */struct file *find_file(struct child_process_elem *process,int fd);/* struct stores the information of file and file description, this struct could be stored in the file list of process */struct file_elem{/* store the information of file */   struct file *file;/* store the file description */   int fd;/* list_elem for file list */   struct list_elem elem;};/* open file by name, return fd */int open (const char *file);******************************************************************************************>> B2: Describe how file descriptors are associated with open files.>> Are file descriptors unique within the entire OS or just within a>> single process?******************************************************************************************In our implementation, each time we successfully call open(file) we would create a file_elem which contains the file description of such file, that would be a one-to-one mapping. Before we add the file_elem to the file list of current process, we would allocate the fd value according to the process’s next_fd value. Such value is initialized to be 2 with the process was created. Each the file descriptors are unique within a process. If the process open the same file several times, there would be several file_elm generated and have different file description.******************************************************************************************---- ALGORITHMS ---->> B3: Describe your code for reading and writing user data from the>> kernel.******************************************************************************************In Read, because the standard read system call contains three parameters which is contained in intr_frame f, we first use the function check_valid_esp() to check whether the(f->esp+4),(f->esp+8)and(f->esp+12) is valid and whether there is a mapping in the user space for such address. Then we get the value according to the those address.(f->esp+4)should be fd,(f->esp+12)should be Buffer, and (f->esp+12)should be the SIZE. Before we run the read() function to read things in the buffer, we would first check if the address of buffer to buffer+size is valid and mapped. Once any address is not good, we would force the process to exit. In read(), we would check the fd value, if fd=0, read the keyboard input;else read the file with such fd. If no such file exist, return -1; else return size.In Write, we do the same thing to check the buffer and f->esp value. Then we call write(). In write(), we just check the fd. If fd=1 output the context in the buffer to the screen; else, write the context to the file with such fd. If no such file, return -1; else, return size.****************************************************************************************** >> B4: Suppose a system call causes a full page (4,096 bytes) of data>> to be copied from user space into the kernel.  What is the least>> and the greatest possible number of inspections of the page table>> (e.g. calls to pagedir_get_page()) that might result?  What about>> for a system call that only copies 2 bytes of data?  Is there room>> for improvement in these numbers, and how much?******************************************************************************************The least value should be 1. If we are lucky enough, we could get all the data in a same page and we could get a head of the page in the first inspections.If the 4096bytes of data is discrete in 4096 command,and copied separately, in the worst case, we need 4096 pages to contain this data and we have to check all the addresses to make sure the validation. If the 4096bytes are a entirety, we would at most need 2 pages to contain the data. So the maximum number would 2.For two bytes, the least value would be the same, since 1 page could at most contain 4096bytes of data which is far more than 2bytes. The greatest value would be 2 when the 2bytes would accidentally be in two pages.Improvement: Do not use the check_valid_esp() to check the address for buffer. Just let the program continue so that it would cause page_fault() to be triggered when any bad address is accessed. We could modify the page_fault() function to deal with it. If the address is correct, we have no need to check do inspections. That would be much faster than check the address each time.******************************************************************************************>> B5: Briefly describe your implementation of the "wait" system call>> and how it interacts with process termination.******************************************************************************************In Wait, the program would first find the child with the pid in the child_process_list of current process use get_child(). If there is no such child or the process had already called Wait for that child, the Wait system call would return 1. Then the program would set the process_wait value of the child to be true to prevent twice wait. After finished, the process would sema_down the wait_barrier of this child and wait until someone call the sema_up to the same wait_barrier. This process would be blocked until the wait is terminated. The semaphore value of wait_barrier is initialized to 0 when a process is created by their parent. When the process exit, it would sema_up the wait_barrier. So whether the process is a zombie or not, the wait_barrier would be 1 after the process_exit()(i.e. the process is terminated by some reason.) and that would wake the parent process up. The differences exist when the child process is a zombie is that there is no need for the parent to block and wait for the seam_down finished since the semaphore wait_barrier had already been raised to 1 when the process exit.When the system call Exit happens, there is one thing the child process would do before call the process_exit(). It would first check if the parent is still alive. If the parent is dead, all the child_process_elem are freed so its not safe to visit it. The program would directly call thread_exit(). If the parent is still alive(i.e. it’s safe to visit thread->process), it would set the status to the input status as a return value and set the process->exit to true, then call the thread_exit().When the parent is alive and wait, the process_exit() would terminate that wait. After finished waiting, the parent would check whether the process->exit of this child is true. If it is not true, the process should be forced to terminated out of a Exit call and the Wait should return -1. Next, the parent would get the value from process->status of child and remove the child by remove_child()(this function would remove the child from list and free the memory).Finally, the parent would return the value it get.******************************************************************************************>> B6: Any access to user program memory at a user-specified address>> can fail due to a bad pointer value.  Such accesses must cause the>> process to be terminated.  System calls are fraught with such>> accesses, e.g. a "write" system call requires reading the system>> call number from the user stack, then each of the call's three>> arguments, then an arbitrary amount of user memory, and any of>> these can fail at any point.  This poses a design and>> error-handling problem: how do you best avoid obscuring the primary>> function of code in a morass of error-handling?  Furthermore, when>> an error is detected, how do you ensure that all temporarily>> allocated resources (locks, buffers, etc.) are freed?  In a few>> paragraphs, describe the strategy or strategies you adopted for>> managing these issues.  Give an example.******************************************************************************************We actually have two methods to prevent harmful access to the kernel stack and bad address. One methods is that we use check_valid_esp()function to check all of the address would need to access before we really access to this address. This function would check whether the input pointer are in kernel space and whether this address is mapped. Either one of the check is failed, the function would force the process to exit to prevent harmful access. The second method is used to prevent the harmful accessing of user program code while the first one is used only for system calls. The second method would take the advantage of page_fault function. This function could identify where the fault address is and whether it is caused by user program or the kernel. If the fault is caused by user program, we would force the process to exit.In process_exit(), we would check if there is any resources such as opened file, child process unit and page exist. Then we would remove and free all this resources. For locks, we take the advantage of our first project which give us a lock list for all the locks acquired by current process. We could simply release all the lock in the list. Besides, we would use file_close() to release the right for writing to the file the process is executing(We disabled it when we successfully load the file in process_execute() function). We do those things in process_exit to ensure all the resources which is need to be freed is released. And that is the reason why I introduce a parameter ‘parent’ in each thread. The free in the process_exit would cause it unsafe to access the child process unit when the orphans process call a Exit system call.For the first method, a good example would be the write-bad-ptr test. Because the program call a Write system call for a bad buffer ptr address 0x102123420. This address would cause the check_valid_esp() call exit(-1) and prevent bad access.For the second method, a good example would be bad-read test. This time, no system call is called but the user program try to access to a unmapped address. No system call means the check_valid_esp is not available and the such access would trigger the page_fault(). Because the bad access is done by user program, the page_fault() would directly call exit(-1) to prevent further operation which is harmful.******************************************************************************************---- SYNCHRONIZATION ---->> B7: The "exec" system call returns -1 if loading the new executable>> fails, so it cannot return before the new executable has completed>> loading.  How does your code ensure this?  How is the load>> success/failure status passed back to the thread that calls "exec"?******************************************************************************************Once the parent process execute a child process, it sema_down the semaphore load_barrier which is initialized to 0 of such child process. The sema_down would cause the parent block and wait. Actually after the process_execute() function which would be executed before sema_down is finished in a Exec system call, the process unit and thread of child is already created. Thus, when the sema_down is called, the child process should run or finish load function. At the end of load() function, we set the load value of child process to same as the value of success/failure and then we sema_up the load_barrier of the child process. At this point, the parent would be woke up and read the value of child’s process->load. If load is false, return -1 ; else return the child pid.Since the semaphore would only be up when the load is completed and the process->load is set before sema_up, we could ensure that the load value would be read after the completed loading and that is the value of success/failure status of load function.******************************************************************************************>> B8: Consider parent process P with child process C.  How do you>> ensure proper synchronization and avoid race conditions when P>> calls wait(C) before C exits?  After C exits?  How do you ensure>> that all resources are freed in each case?  How about when P>> terminates without waiting, before C exits?  After C exits?  Are>> there any special cases?******************************************************************************************Just as we claimed when we introduced our process_wait() procedure, we used a semaphore named wait_barrier in each child process to realize the wait process. Besides, we have a child_process_list in all process to store all the return status for each child. The status is store in the child_process_elem distinctively. Thus, there should be no race condition.There are four possible conditions:P calls wait before C calls exit: In this condition, P would be block until C call a exit by sema_down(C->wait_barrier). When C exit, because P is still alive, C->status would be set to exit status and then C would call sema_up(C->wait_barrier). P would be woke up and get such status.P calls wait after C calls exit: In this condition, C call a exit, and C find that P is alive. So C set the C->status to the exit status and sema_up(C->wait_barrier). Then C thread exit and is freed. However, the process unit which contains the exit information would not be freed by process_exit() and thread_exit(). So when P call wait later, process unit of C is still accessible. Because the semaphore is already upped and now the value is 1, the sema_down would immediately pass and P could get the status from process unit of C. After doing that, P would remove the unit from child_process_list and free the process unit of C. When P exits, since C is freed and removed from the list, no secondary free would happen.P terminated without waiting before C calls exit: Once P is terminated, the P thread would be removed from all_list and all the child process unit contained by the child_process_list is freed and it is unsafe to visit those unit. When C call exit, before access to the process unit of C which is already freed, it would first check if the parent P is still alive. Since P is terminated, C would directly run thread_exit() instead of modifying the process unit. Thus, unsafe access is avoid.P terminated after C calls exit: P just free all the resources including the process unit of C.When C exits, C would free all the file, lock and child process resources it holds. When P exists, P would free all the file, lock and child process including the Process unit of C. When P’s parent exits, P’s would free all the file, lock and child process including the Process unit of P. And that process would continue until the First idle thread exit. This thread is not binding with any process unit thus there is no need to free its own process unit. At this time, all other process unit is freed by their parent and the ancestor have no process unit. Thus, the memory is clean out.However, one potential problem may happen, if C passed the check of thread_exist(parent) and is going to modify the C process unit. And at the same time P is terminated and is freeing C process unit, a dangerous conflict may happen. However, that should be extremely rare.******************************************************************************************---- RATIONALE ---->> B9: Why did you choose to implement access to user memory from the>> kernel in the way that you did?******************************************************************************************We choose the first way which call a pagedir_get_page() and is_user_vaddr() to check the validation of pointer before we use it. We just use the page_fault() function to check the user program. We choose this method because this method is easier and there is no need to figure out the concept of each pagefault condition. We are forced to fix page_fault() for a user program because the first method is not available in this case.******************************************************************************************>> B10: What advantages or disadvantages can you see to your design>> for file descriptors?Avantages:Because we set a file_list for each process, the searching time for a fixed fd would be short.We use the user space to store the file descriptors, so the kernel space is maximized.We used list to store the file descriptor, so the size of list is dynamic.Disadvantages:Used lots of user space, there is a potential threat for the user memory overflow.No inheritance is implemented.Hard to do allocation of distinct files.>> B11: The default tid_t to pid_t mapping is the identity mapping.>> If you changed it, what advantages are there to your approach?******************************************************************************************We do not change it. Since in our system, all the process is single-threaded and tid_t could be the same as pid_t.However, since a process may contains several threads, a single pid_t should binding with multiple tid_t. So a changing may be more practical.******************************************************************************************			   SURVEY QUESTIONS			   ================Answering these questions is optional, but it will help us improve thecourse in future quarters.  Feel free to tell us anything youwant--these questions are just to spur your thoughts.  You may alsochoose to respond anonymously in the course evaluations at the end ofthe quarter.>> In your opinion, was this assignment, or any one of the three problems>> in it, too easy or too hard?  Did it take too long or too little time?>> Did you find that working on a particular part of the assignment gave>> you greater insight into some aspect of OS design?>> Is there some particular fact or hint we should give students in>> future quarters to help them solve the problems?  Conversely, did you>> find any of our guidance to be misleading?>> Do you have any suggestions for the TAs to more effectively assist>> students, either for future quarters or the remaining projects?>> Any other comments?